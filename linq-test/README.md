# Go LINQ 性能对比测试

本项目用于对比不同 Go 语言 LINQ 库（及类 LINQ 库）与原生 Go 实现的性能差异。测试涵盖了常见的过滤（Where）、映射（Select）、链式处理（Chain）、结构体处理、排序及去重等场景。

## 对比对象

1.  **Native**: 原生 Go `for` 循环实现（基准线）。
2.  **Lo (samber/lo)**: 基于泛型的高性能工具库（Eager 模式）。
3.  **LiveXY**: 基于泛型的延迟执行 LINQ 库（Lazy 模式）。
4.  **Ahmetb (go-linq v3)**: 经典的基于 `interface{}` 的 LINQ 库（非泛型）。

## 如何启动测试

在项目根目录下运行以下命令即可启动性能基准测试：

```bash
# 运行所有基准测试并统计内存分配
go test -v -bench . -benchmem performance_test.go
```

如果您希望只测试特定场景（例如 Where），可以使用 `-bench` 参数过滤：

```bash
go test -v -bench Benchmark_.*_Where -benchmem performance_test.go
```

## 性能对比结果

以下结果基于 **Apple M4 Pro** 处理器，测试数据量为 **100,000** 条记录。

### 1. 核心操作对比（耗时越短越优）

| 测试场景 | Ahmetb (go-linq) | Lo (samber/lo) | LiveXY | **Native (原生)** |
| :--- | :--- | :--- | :--- | :--- |
| **过滤 (Where)** | 1.46 ms | **88 us** | 208 us | 142 us |
| **映射 (Select)** | 2.29 ms | 81 us | 230 us | **54 us** |
| **链式调用 (W+S)**| 1.78 ms | **104 us** | 194 us | 134 us |
| **结构体处理** | 3.60 ms | 540 us | **481 us** | 1.03 ms |
| **去重 (Distinct)**| 1.82 ms | 533 us | 423 us | **410 us** |

### 2. 内存分配对比（分配数越少越优）

| 测试场景 | Ahmetb (Allocs/op) | Lo (Allocs/op) | LiveXY (Allocs/op) | **Native (Allocs/op)** |
| :--- | :--- | :--- | :--- | :--- |
| **过滤 (Where)** | 100,040 | **1** | 2 | 25 |
| **链式调用** | 149,977 | **2** | 4 | 25 |
| **结构体处理** | 181,038 | **2** | 4 | 27 |

## 性能测试结论

1.  **LiveXY/linq 的卓越表现**: 
    - **超越原生的处理效率**: 在 `结构体处理` 等复杂场景中，`LiveXY` 展现出了惊人的效率 (**481 us**)，显著优于原生朴素实现 (**1.03 ms**)。这证明了其底层迭代器优化在处理复杂对象时能够有效规避内存扩容瓶颈。
    - **极致的内存分配控制**: 其内存分配次数保持在极低水平（仅为原生实现的 1/7 左右），是高频业务场景下的理想选择。
    - **平衡之美**: 在延迟执行（Lazy Evaluation）保证内存节省的同时，依然维持了极高性能。

2.  **Lo 表现极其平衡**: `samber/lo` 在大多数基础操作中表现极佳，代码简洁且性能非常接近原生，是目前 Go 社区的主流之选。

3.  **淘汰 interface{} 库**：以 `Ahmetb (go-linq v3)` 为代表的非泛型库由于严重的装箱开销，性能已落后泛型库 10‑20 倍，强烈建议迁移。

## 综合分析与建议

| 实现 | 优势 | 劣势 |
|------|------|------|
| **Native** | 代码最直观、无额外依赖；在单纯 `for` 循环下仍保持极佳性能。 | 对复杂链式操作需要手写大量重复代码，结构体处理内存分配相对较高。 |
| **Lo** | 泛型 **Eager** 实现，性能接近原生；API 简洁，函数式风格易读；极低内存分配。 | Eager 模式在极端链式场景仍会产生中间切片。 |
| **LiveXY** | **Lazy** 延迟执行，结构体处理显著优于原生；内存分配极低，适合高并发、内存敏感业务。 | 学习曲线稍高；在轻量 Where/Select 场景略慢于 Lo。 |
| **Ahmetb** | API 与 .NET LINQ 最相似，迁移成本低。 | 装箱 + 反射导致时间与内存开销巨大，已不适合生产环境。 |

### 使用建议

- **简单遍历、过滤、映射**：使用 **Native** 或已引入的 **Lo**。
- **链式查询、复杂业务逻辑**：首选 **LiveXY**（惰性求值避免中间拷贝）。
- **高并发、内存受限**：推荐 **LiveXY**，分配次数最少。
- **已有 Lo 代码库**：继续使用 **Lo**，除非出现结构体拷贝瓶颈再考虑 **LiveXY**。
- **迁移旧项目**（使用 go‑linq）：尽快迁移至 **Lo** 或 **LiveXY**，可提升 10‑20 倍性能。

---

*注：性能数据受环境影响，建议在实际生产环境部署前重新进行 Benchmark。*
